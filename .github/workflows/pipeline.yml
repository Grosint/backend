name: Grosint Backend CI/CD Pipeline

on:
    push:
        branches: [main] # Currently set to main for testing
    pull_request:
        branches: [develop, production, main]

env:
    PYTHON_VERSION: '3.12.7'
    COVERAGE_THRESHOLD: 10

jobs:
    lint:
        name: üîç Lint Code
        runs-on: ubuntu-latest
        steps:
            - name: Checkout code
              uses: actions/checkout@v4

            - name: Set up Python ${{ env.PYTHON_VERSION }}
              uses: actions/setup-python@v4
              with:
                  python-version: ${{ env.PYTHON_VERSION }}
                  cache: 'pip'

            - name: Install dependencies
              run: |
                  python -m pip install --upgrade pip
                  pip install -r requirements.txt
                  pip install -r requirements-dev.txt

            - name: Black formatting check
              run: |
                  black --version
                  black --check --diff app/ tests/

            - name: Ruff linting and import sorting check
              run: |
                  ruff check app/ tests/
                  ruff check --select I app/ tests/

            - name: Security check with Bandit
              run: bandit -r app/ --skip B101

    test:
        name: üß™ Test & Coverage
        runs-on: ubuntu-latest
        needs: lint

        steps:
            - name: Checkout code
              uses: actions/checkout@v4

            - name: Set up Python ${{ env.PYTHON_VERSION }}
              uses: actions/setup-python@v4
              with:
                  python-version: ${{ env.PYTHON_VERSION }}
                  cache: 'pip'

            - name: Install dependencies
              run: |
                  python -m pip install --upgrade pip
                  pip install -r requirements.txt
                  pip install -r requirements-dev.txt

            - name: Start MongoDB container for testing
              run: |
                  docker compose -f docker-compose.test.yml up -d mongodb-test

                  # Wait for MongoDB to be ready
                  echo "Waiting for MongoDB to be ready..."
                  for i in {1..12}; do
                    if docker compose -f docker-compose.test.yml exec -T mongodb-test mongosh --eval "db.adminCommand('ping')" --quiet; then
                      echo "‚úÖ MongoDB is ready!"
                      break
                    elif [ $i -eq 12 ]; then
                      echo "‚ùå MongoDB failed to start"
                      docker compose -f docker-compose.test.yml logs mongodb-test
                      exit 1
                    fi
                    sleep 5
                  done

            - name: Run tests with coverage
              env:
                  MONGODB_URL: mongodb://testuser:testpass@localhost:27018/test_osint_backend?authSource=admin
                  PYTHONPATH: ${{ github.workspace }}
              run: |
                  # Run tests with coverage
                  coverage run -m pytest tests/ -v --tb=short
                  coverage report --show-missing
                  coverage xml
                  coverage html

            - name: Prepare SonarCloud scan
              run: |
                  # Create target directory for SonarCloud metadata
                  mkdir -p target/sonar
                  echo "SonarCloud scan preparation completed"

                  # Debug: Check if coverage file exists
                  if [ -f "coverage.xml" ]; then
                    echo "‚úÖ Coverage file exists: $(ls -la coverage.xml)"
                  else
                    echo "‚ùå Coverage file not found"
                  fi

                  # Debug: Check project structure
                  echo "Project structure:"
                  ls -la app/ || echo "app/ directory not found"
                  ls -la tests/ || echo "tests/ directory not found"

            - name: Check coverage threshold
              run: |
                  COVERAGE=$(coverage report --format=total)
                  echo "Current coverage: $COVERAGE%"
                  echo "Required coverage: ${{ env.COVERAGE_THRESHOLD }}%"

                  if (( $(echo "$COVERAGE < ${{ env.COVERAGE_THRESHOLD }}" | bc -l) )); then
                    echo "‚ùå Coverage $COVERAGE% is below threshold ${{ env.COVERAGE_THRESHOLD }}%"
                    exit 1
                  else
                    echo "‚úÖ Coverage $COVERAGE% meets threshold"
                  fi

            - name: Check SonarCloud Configuration
              run: |
                  if [ -z "${{ secrets.SONARCLOUD_TOKEN }}" ]; then
                    echo "‚ùå SONARCLOUD_TOKEN secret is not configured"
                    echo "Skipping SonarCloud scan"
                    echo "SONARCLOUD_TOKEN=" >> $GITHUB_ENV
                    exit 0
                  else
                    echo "‚úÖ SonarCloud token is configured"
                    echo "SONARCLOUD_TOKEN=${{ secrets.SONARCLOUD_TOKEN }}" >> $GITHUB_ENV
                  fi

                  if [ -z "${{ secrets.SONARCLOUD_ORG }}" ]; then
                    echo "‚ö†Ô∏è  SONARCLOUD_ORG secret is not configured, attempting to auto-detect..."

                    # Try to get organization from SonarCloud API
                    ORG_RESPONSE=$(curl -s -u "${{ secrets.SONARCLOUD_TOKEN }}:" "https://sonarcloud.io/api/organizations/search" || echo "")

                    if [ -n "$ORG_RESPONSE" ] && echo "$ORG_RESPONSE" | grep -q '"key"'; then
                      # Extract the first organization key
                      ORG_KEY=$(echo "$ORG_RESPONSE" | grep -o '"key":"[^"]*"' | head -1 | cut -d'"' -f4)
                      if [ -n "$ORG_KEY" ]; then
                        echo "‚úÖ Auto-detected organization: $ORG_KEY"
                        echo "SONARCLOUD_ORG=$ORG_KEY" >> $GITHUB_ENV
                      else
                        echo "‚ùå Could not extract organization key from API response"
                        echo "Please set SONARCLOUD_ORG secret manually"
                        echo "You can find it at: https://sonarcloud.io/organizations/"
                        exit 1
                      fi
                    else
                      echo "‚ùå Could not connect to SonarCloud API or no organizations found"
                      echo "Trying alternative method..."

                      # Alternative: Try to get organization from project info
                      PROJECT_RESPONSE=$(curl -s -u "${{ secrets.SONARCLOUD_TOKEN }}:" "https://sonarcloud.io/api/projects/search?projects=Grosint_backend" || echo "")
                      if [ -n "$PROJECT_RESPONSE" ] && echo "$PROJECT_RESPONSE" | grep -q '"organization"'; then
                        ORG_KEY=$(echo "$PROJECT_RESPONSE" | grep -o '"organization":"[^"]*"' | head -1 | cut -d'"' -f4)
                        if [ -n "$ORG_KEY" ]; then
                          echo "‚úÖ Auto-detected organization from project: $ORG_KEY"
                          echo "SONARCLOUD_ORG=$ORG_KEY" >> $GITHUB_ENV
                        else
                          echo "‚ùå Could not extract organization from project info"
                          echo "Please set SONARCLOUD_ORG secret manually"
                          echo "You can find it at: https://sonarcloud.io/organizations/"
                          exit 1
                        fi
                      else
                        echo "‚ùå Could not connect to SonarCloud API or project not found"
                        echo "Please set SONARCLOUD_ORG secret manually"
                        echo "You can find it at: https://sonarcloud.io/organizations/"
                        exit 1
                      fi
                    fi
                  else
                    echo "‚úÖ SonarCloud organization is configured"
                    echo "SONARCLOUD_ORG=${{ secrets.SONARCLOUD_ORG }}" >> $GITHUB_ENV
                  fi

            - name: Test SonarCloud Connection
              if: env.SONARCLOUD_TOKEN != ''
              run: |
                  echo "Testing SonarCloud connection..."
                  curl -s -u "${{ secrets.SONARCLOUD_TOKEN }}:" "https://sonarcloud.io/api/authentication/validate" || echo "Connection test failed"

                  echo "Organization: ${{ env.SONARCLOUD_ORG }}"
                  echo "Project Key: Grosint_backend"

            - name: Update SonarCloud Properties
              if: env.SONARCLOUD_TOKEN != ''
              run: |
                  echo "Updating sonar-project.properties with detected organization..."
                  # Update the organization in sonar-project.properties
                  sed -i "s/sonar.organization=.*/sonar.organization=${{ env.SONARCLOUD_ORG }}/" sonar-project.properties
                  echo "Updated sonar-project.properties:"
                  cat sonar-project.properties

            - name: Disable Automatic Analysis
              if: env.SONARCLOUD_TOKEN != ''
              run: |
                  echo "Disabling automatic analysis for CI compatibility..."

                  # Check current automatic analysis status
                  echo "Checking current automatic analysis status..."
                  STATUS_RESPONSE=$(curl -s -u "${{ secrets.SONARCLOUD_TOKEN }}:" "https://sonarcloud.io/api/automatic_analysis/status?project=Grosint_backend")
                  echo "Current status: $STATUS_RESPONSE"

                  # Disable automatic analysis via API
                  echo "Attempting to disable automatic analysis..."
                  DISABLE_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
                    -u "${{ secrets.SONARCLOUD_TOKEN }}:" \
                    "https://sonarcloud.io/api/automatic_analysis/disable" \
                    -d "project=Grosint_backend")

                  HTTP_CODE=$(echo "$DISABLE_RESPONSE" | tail -n1)
                  RESPONSE_BODY=$(echo "$DISABLE_RESPONSE" | head -n -1)

                  echo "HTTP Status: $HTTP_CODE"
                  echo "Response: $RESPONSE_BODY"

                  if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "204" ]; then
                    echo "‚úÖ Automatic analysis disabled successfully"
                  else
                    echo "‚ö†Ô∏è  Failed to disable automatic analysis via API (HTTP $HTTP_CODE)"
                    echo "You may need to disable it manually in SonarCloud project settings"
                  fi

            - name: SonarCloud Scan
              if: env.SONARCLOUD_TOKEN != ''
              uses: SonarSource/sonarqube-scan-action@master
              env:
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
                  SONAR_TOKEN: ${{ secrets.SONARCLOUD_TOKEN }}
              with:
                  args: >
                      -Dsonar.organization=${{ env.SONARCLOUD_ORG }}
                      -Dsonar.host.url=https://sonarcloud.io
              continue-on-error: true

            - name: SonarCloud Scan Fallback
              if: env.SONARCLOUD_TOKEN != '' && failure()
              run: |
                  echo "‚ùå SonarCloud scan failed due to automatic analysis conflict"
                  echo ""
                  echo "üîß TO FIX THIS ISSUE:"
                  echo "1. Go to your SonarCloud project: https://sonarcloud.io/project/overview?id=Grosint_backend"
                  echo "2. Click on 'Administration' ‚Üí 'Analysis Method'"
                  echo "3. Disable 'Automatic Analysis'"
                  echo "4. Save the changes"
                  echo "5. Re-run this pipeline"
                  echo ""
                  echo "This will allow CI analysis to work properly."
                  echo "The pipeline will continue without SonarCloud analysis for now."

            - name: Check SonarCloud Scan Results
              if: env.SONARCLOUD_TOKEN != ''
              run: |
                  if [ -f "target/sonar/report-task.txt" ]; then
                    echo "‚úÖ SonarCloud scan completed successfully"
                    echo "SONARCLOUD_SCAN_SUCCESS=true" >> $GITHUB_ENV
                  else
                    echo "‚ùå SonarCloud scan failed or was skipped"
                    echo "SONARCLOUD_SCAN_SUCCESS=false" >> $GITHUB_ENV
                  fi

            - name: SonarCloud Quality Gate
              if: env.SONARCLOUD_TOKEN != '' && env.SONARCLOUD_SCAN_SUCCESS == 'true'
              uses: SonarSource/sonarqube-quality-gate-action@master
              env:
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
                  SONAR_TOKEN: ${{ secrets.SONARCLOUD_TOKEN }}
              with:
                  scanMetadataReportFile: target/sonar/report-task.txt

            - name: SonarCloud Quality Gate Skipped
              if: env.SONARCLOUD_TOKEN != '' && env.SONARCLOUD_SCAN_SUCCESS == 'false'
              run: |
                  echo "‚è≠Ô∏è  Skipping SonarCloud Quality Gate - scan was not successful"
                  echo "This is expected when automatic analysis is enabled in SonarCloud"

            - name: Stop MongoDB container
              if: always()
              run: docker compose -f docker-compose.test.yml down -v

            - name: Upload coverage reports
              uses: actions/upload-artifact@v4
              with:
                  name: coverage-reports
                  path: |
                      coverage.xml
                      htmlcov/

    build:
        name: üèóÔ∏è Build Application
        runs-on: ubuntu-latest
        needs: [lint, test]

        steps:
            - name: Checkout code
              uses: actions/checkout@v4

            - name: Create deployment package
              run: |
                  mkdir -p dist

                  # Copy application files
                  cp -r app/ dist/
                  cp requirements.txt dist/
                  cp run.py dist/

                  # Create systemd service file
                  cat > dist/grosint-backend.service << 'EOF'
                  [Unit]
                  Description=Grosint FastAPI Backend
                  After=network.target

                  [Service]
                  Type=exec
                  User=root
                  Group=root
                  WorkingDirectory=/opt/grosint-backend
                  Environment=PYTHONPATH=/opt/grosint-backend
                  ExecStart=/opt/grosint-backend/venv/bin/uvicorn app.main:app --host 127.0.0.1 --port 8000 --workers 4
                  Restart=always
                  RestartSec=10
                  StandardOutput=journal
                  StandardError=journal

                  [Install]
                  WantedBy=multi-user.target
                  EOF

                  # Create nginx configuration
                  cat > dist/nginx-grosint.conf << 'EOF'
                  server {
                      listen 80;
                      server_name _;  # Accept any server name (for IP access)

                      # Client max body size
                      client_max_body_size 50M;

                      # Main application
                      location / {
                          proxy_pass http://127.0.0.1:8000;
                          proxy_set_header Host $host;
                          proxy_set_header X-Real-IP $remote_addr;
                          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                          proxy_set_header X-Forwarded-Proto $scheme;
                          proxy_connect_timeout 60s;
                          proxy_send_timeout 60s;
                          proxy_read_timeout 60s;
                      }

                      # Health check endpoint
                      location /health {
                          proxy_pass http://127.0.0.1:8000/health;
                          access_log off;
                      }
                  }
                  EOF

                  # Create deployment script
                  cat > dist/deploy.sh << 'EOF'
                  #!/bin/bash
                  set -e

                  echo "üöÄ Starting deployment..."

                  # Create Python virtual environment
                  python3.12 -m venv venv
                  source venv/bin/activate
                  pip install --upgrade pip
                  pip install -r requirements.txt

                  echo "‚úÖ Dependencies installed"
                  EOF
                  chmod +x dist/deploy.sh

                  # Environment file will be created during deployment using GitHub Secrets

                  echo "Build package created successfully"
                  ls -la dist/

            - name: Upload build artifacts
              uses: actions/upload-artifact@v4
              with:
                  name: build-artifacts
                  path: dist/

    deploy:
        name: üöÄ Deploy to Production
        runs-on: ubuntu-latest
        needs: [lint, test, build]
        if: github.ref == 'refs/heads/main' && github.event_name == 'push'
        environment:
            name: production

        steps:
            - name: Set deployment URL
              run: |
                  echo "Deployment URL: http://${{ secrets.DOMAIN_NAME }}:8000"
                  echo "DEPLOYMENT_URL=http://${{ secrets.DOMAIN_NAME }}:8000" >> $GITHUB_ENV

            - name: Download build artifacts
              uses: actions/download-artifact@v4
              with:
                  name: build-artifacts
                  path: dist/

            - name: Deploy to Azure VM
              uses: appleboy/ssh-action@v1.1.0
              with:
                  host: ${{ secrets.AZURE_VM_HOST }}
                  username: ${{ secrets.AZURE_VM_USERNAME }}
                  key: ${{ secrets.AZURE_VM_SSH_KEY }}
                  script_stop: true
                  script: |
                      echo "üõë Stopping current application..."
                      sudo systemctl stop grosint-backend || echo "Service not running"

                      # Create backup
                      if [ -d "/opt/grosint-backend" ]; then
                        sudo mv /opt/grosint-backend /opt/grosint-backend.backup.$(date +%Y%m%d_%H%M%S)
                      fi

                      # Create application directory
                      sudo mkdir -p /opt/grosint-backend
                      sudo chown $USER:$USER /opt/grosint-backend

            - name: Copy files to server
              uses: appleboy/scp-action@v0.1.4
              with:
                  host: ${{ secrets.AZURE_VM_HOST }}
                  username: ${{ secrets.AZURE_VM_USERNAME }}
                  key: ${{ secrets.AZURE_VM_SSH_KEY }}
                  source: 'dist/*'
                  target: '/opt/grosint-backend'
                  strip_components: 1

            - name: Complete deployment
              uses: appleboy/ssh-action@v1.0.0
              with:
                  host: ${{ secrets.AZURE_VM_HOST }}
                  username: ${{ secrets.AZURE_VM_USERNAME }}
                  key: ${{ secrets.AZURE_VM_SSH_KEY }}
                  script: |
                      cd /opt/grosint-backend

                      # Debug: List all files to verify copying
                      echo "Files in deployment directory:"
                      ls -la

                      # Debug: Check user and permissions
                      echo "Current user: $(whoami)"
                      echo "User ID: $(id)"
                      echo "Virtual environment check:"
                      ls -la venv/bin/uvicorn || echo "uvicorn not found in venv/bin/"
                      echo "Python check:"
                      which python3.12 || echo "python3.12 not found"

                      # Set up application
                      chmod +x deploy.sh
                      ./deploy.sh

                      # Create .env file from GitHub Secrets
                      echo "Creating .env file from GitHub Secrets..."
                      cat > .env << EOF
                      # MongoDB Atlas Configuration
                      MONGODB_URL=${{ secrets.MONGODB_URL }}

                      # Application Configuration
                      DEBUG=false
                      LOG_LEVEL=info
                      SECRET_KEY=${{ secrets.SECRET_KEY }}

                      # Environment
                      ENVIRONMENT=production
                      EOF
                      echo "‚úÖ .env file created with production secrets"

                      # Create logs directory with proper permissions
                      sudo mkdir -p /opt/grosint-backend/logs
                      sudo chown $USER:$USER /opt/grosint-backend/logs
                      sudo chmod 755 /opt/grosint-backend/logs

                      # Install systemd service
                      sudo cp grosint-backend.service /etc/systemd/system/
                      sudo systemctl daemon-reload
                      sudo systemctl enable grosint-backend

                      # Set proper ownership for all files
                      sudo chown -R root:root /opt/grosint-backend
                      sudo chmod -R 755 /opt/grosint-backend

                      # Set up nginx
                      sudo cp nginx-grosint.conf /etc/nginx/sites-available/grosint-backend
                      sudo ln -sf /etc/nginx/sites-available/grosint-backend /etc/nginx/sites-enabled/
                      sudo nginx -t
                      sudo systemctl reload nginx

                      # Start application
                      sudo systemctl start grosint-backend

                      # Wait and health check
                      echo "‚è≥ Waiting for application to start..."
                      sleep 15

                      # Health check
                      for i in {1..6}; do
                        if curl -f http://127.0.0.1:8000/health >/dev/null 2>&1; then
                          echo "‚úÖ Application health check passed!"
                          break
                        elif [ $i -eq 6 ]; then
                          echo "‚ùå Health check failed!"
                          sudo journalctl -u grosint-backend --no-pager -n 20
                          exit 1
                        else
                          echo "Attempt $i/6 failed, retrying..."
                          sleep 5
                        fi
                      done

                      echo "‚úÖ Deployment completed successfully!"
                      sudo systemctl status grosint-backend --no-pager

    notify:
        name: üì¢ Slack Notification
        runs-on: ubuntu-latest
        needs: [lint, test, build, deploy]
        if: always()

        steps:
            - name: Set deployment URL
              run: |
                  echo "DEPLOYMENT_URL=http://${{ secrets.DOMAIN_NAME }}:8000" >> $GITHUB_ENV

            - name: Check Slack Configuration
              run: |
                  if [ -z "${{ secrets.SLACK_WEBHOOK_URL }}" ]; then
                    echo "‚ùå SLACK_WEBHOOK_URL secret is not configured"
                    echo "Please add SLACK_WEBHOOK_URL to your repository secrets"
                    exit 1
                  else
                    echo "‚úÖ Slack webhook URL is configured"
                  fi

            - name: Notify Success
              if: needs.deploy.result == 'success'
              uses: 8398a7/action-slack@v3
              env:
                  SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
              with:
                  status: success
                  channel: '#deployments'
                  custom_payload: |
                      {
                        "attachments": [
                          {
                            "color": "good",
                            "title": "üéâ Deployment Successful!",
                            "fields": [
                              {
                                "title": "Repository",
                                "value": "${{ github.repository }}",
                                "short": true
                              },
                              {
                                "title": "Branch",
                                "value": "${{ github.ref_name }}",
                                "short": true
                              },
                              {
                                "title": "Commit",
                                "value": "${{ github.sha }}",
                                "short": true
                              },
                              {
                                "title": "Author",
                                "value": "${{ github.actor }}",
                                "short": true
                              }
                            ],
                            "actions": [
                              {
                                "type": "button",
                                "text": "View App",
                                "url": "${{ env.DEPLOYMENT_URL }}"
                              },
                              {
                                "type": "button",
                                "text": "View Logs",
                                "url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                              }
                            ]
                          }
                        ]
                      }

            - name: Notify Failure
              if: needs.lint.result == 'failure' || needs.test.result == 'failure' || needs.build.result == 'failure' || needs.deploy.result == 'failure' || needs.lint.result == 'cancelled' || needs.test.result == 'cancelled' || needs.build.result == 'cancelled' || needs.deploy.result == 'cancelled'
              uses: 8398a7/action-slack@v3
              env:
                  SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
              with:
                  status: failure
                  channel: '#deployments'
                  custom_payload: |
                      {
                        "attachments": [
                          {
                            "color": "danger",
                            "title": "‚ùå Pipeline Failed!",
                            "fields": [
                              {
                                "title": "Repository",
                                "value": "${{ github.repository }}",
                                "short": true
                              },
                              {
                                "title": "Branch",
                                "value": "${{ github.ref_name }}",
                                "short": true
                              },
                              {
                                "title": "Failed Stage",
                                "value": "${{ needs.lint.result == 'failure' && 'Lint' || needs.test.result == 'failure' && 'Test' || needs.build.result == 'failure' && 'Build' || 'Deploy' }}",
                                "short": true
                              },
                              {
                                "title": "Author",
                                "value": "${{ github.actor }}",
                                "short": true
                              }
                            ],
                            "actions": [
                              {
                                "type": "button",
                                "text": "View Logs",
                                "url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                              }
                            ]
                          }
                        ]
                      }

            - name: Notify Skipped
              if: needs.deploy.result == 'skipped' && (needs.lint.result == 'success' && needs.test.result == 'success' && needs.build.result == 'success')
              uses: 8398a7/action-slack@v3
              env:
                  SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
              with:
                  status: success
                  channel: '#deployments'
                  custom_payload: |
                      {
                        "attachments": [
                          {
                            "color": "warning",
                            "title": "‚ö†Ô∏è Pipeline Passed (No Deployment)",
                            "fields": [
                              {
                                "title": "Repository",
                                "value": "${{ github.repository }}",
                                "short": true
                              },
                              {
                                "title": "Branch",
                                "value": "${{ github.ref_name }}",
                                "short": true
                              },
                              {
                                "title": "Reason",
                                "value": "Not on main branch - deployment skipped",
                                "short": false
                              },
                              {
                                "title": "Author",
                                "value": "${{ github.actor }}",
                                "short": true
                              }
                            ],
                            "actions": [
                              {
                                "type": "button",
                                "text": "View Logs",
                                "url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                              }
                            ]
                          }
                        ]
                      }

            - name: Debug Slack Configuration
              if: always()
              run: |
                  echo "Slack webhook configured: ${{ secrets.SLACK_WEBHOOK_URL != '' }}"
                  echo "Deploy result: ${{ needs.deploy.result }}"
                  echo "Lint result: ${{ needs.lint.result }}"
                  echo "Test result: ${{ needs.test.result }}"
                  echo "Build result: ${{ needs.build.result }}"
                  echo "Event name: ${{ github.event_name }}"
                  echo "Ref: ${{ github.ref }}"
                  echo "Ref name: ${{ github.ref_name }}"
