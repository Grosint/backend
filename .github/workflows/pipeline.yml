name: Grosint Backend CI/CD Pipeline

on:
    push:
        branches: [main, develop, production] # Currently set to main for testing
    pull_request:
        types: [opened, reopened, synchronize, ready_for_review]
        branches: [main, develop, production]

env:
    PYTHON_VERSION: "3.12.7"
    COVERAGE_THRESHOLD: 10

jobs:
    lint:
        name: üîç Lint Code
        runs-on: ubuntu-latest
        steps:
            - name: Checkout code
              uses: actions/checkout@v4

            - name: Set up Python ${{ env.PYTHON_VERSION }}
              uses: actions/setup-python@v4
              with:
                  python-version: ${{ env.PYTHON_VERSION }}
                  cache: "pip"

            - name: Install dependencies
              run: |
                  python -m pip install --upgrade pip
                  pip install -r requirements.txt
                  pip install -r requirements-dev.txt

            - name: Black formatting check
              run: |
                  black --version
                  black --check --diff app/ tests/

            - name: Ruff linting and import sorting check
              run: |
                  ruff check app/ tests/
                  ruff check --select I app/ tests/

            - name: Security check with Bandit
              run: bandit -r app/ --skip B101

    test:
        name: üß™ Test & Coverage
        runs-on: ubuntu-latest
        needs: lint

        steps:
            - name: Checkout code
              uses: actions/checkout@v4

            - name: Set up Python ${{ env.PYTHON_VERSION }}
              uses: actions/setup-python@v4
              with:
                  python-version: ${{ env.PYTHON_VERSION }}
                  cache: "pip"

            - name: Install dependencies
              run: |
                  python -m pip install --upgrade pip
                  pip install -r requirements.txt
                  pip install -r requirements-dev.txt

            - name: Start MongoDB container for testing
              run: |
                  docker compose -f docker-compose.test.yml up -d mongodb-test

                  # Wait for MongoDB to be ready
                  echo "Waiting for MongoDB to be ready..."
                  for i in {1..12}; do
                    if docker compose -f docker-compose.test.yml exec -T mongodb-test mongosh --eval "db.adminCommand('ping')" --quiet; then
                      echo "‚úÖ MongoDB is ready!"
                      break
                    elif [ $i -eq 12 ]; then
                      echo "‚ùå MongoDB failed to start"
                      docker compose -f docker-compose.test.yml logs mongodb-test
                      exit 1
                    fi
                    sleep 5
                  done

            - name: Run tests with coverage
              env:
                  MONGODB_URL: mongodb://testuser:testpass@localhost:27018/test_osint_backend?authSource=admin
                  PYTHONPATH: ${{ github.workspace }}
              run: |
                  # Run tests with coverage (no GUI interaction)
                  coverage run -m pytest tests/ -v --tb=short
                  coverage report --show-missing
                  coverage xml
                  coverage html

            - name: Prepare SonarCloud scan
              run: |
                  # Create target directory for SonarCloud metadata
                  mkdir -p target/sonar
                  echo "SonarCloud scan preparation completed"

                  # Debug: Check if coverage file exists
                  if [ -f "coverage.xml" ]; then
                    echo "‚úÖ Coverage file exists: $(ls -la coverage.xml)"
                  else
                    echo "‚ùå Coverage file not found"
                  fi

                  # Debug: Check project structure
                  echo "Project structure:"
                  ls -la app/ || echo "app/ directory not found"
                  ls -la tests/ || echo "tests/ directory not found"

            - name: Check coverage threshold
              run: |
                  COVERAGE=$(coverage report --format=total)
                  echo "Current coverage: $COVERAGE%"
                  echo "Required coverage: ${{ env.COVERAGE_THRESHOLD }}%"

                  if (( $(echo "$COVERAGE < ${{ env.COVERAGE_THRESHOLD }}" | bc -l) )); then
                    echo "‚ùå Coverage $COVERAGE% is below threshold ${{ env.COVERAGE_THRESHOLD }}%"
                    exit 1
                  else
                    echo "‚úÖ Coverage $COVERAGE% meets threshold"
                  fi

            - name: Check SonarCloud Configuration
              env:
                  SONARCLOUD_TOKEN: ${{ secrets.SONARCLOUD_TOKEN }}
                  SONARCLOUD_ORG: ${{ secrets.SONARCLOUD_ORG }}
              run: |
                  if [ -z "$SONARCLOUD_TOKEN" ]; then
                    echo "‚ùå SONARCLOUD_TOKEN secret is not configured"
                    echo "Skipping SonarCloud scan"
                    echo "SONARCLOUD_TOKEN=" >> $GITHUB_ENV
                    exit 0
                  else
                    echo "‚úÖ SonarCloud token is configured"
                    echo "SONARCLOUD_TOKEN=$SONARCLOUD_TOKEN" >> $GITHUB_ENV
                  fi

                  if [ -z "$SONARCLOUD_ORG" ]; then
                    echo "‚ö†Ô∏è  SONARCLOUD_ORG secret is not configured, attempting to auto-detect..."

                    # Try to get organization from SonarCloud API
                    ORG_RESPONSE=$(curl -s -u "$SONARCLOUD_TOKEN:" "https://sonarcloud.io/api/organizations/search" || echo "")

                    if [ -n "$ORG_RESPONSE" ] && echo "$ORG_RESPONSE" | grep -q '"key"'; then
                      # Extract the first organization key
                      ORG_KEY=$(echo "$ORG_RESPONSE" | grep -o '"key":"[^"]*"' | head -1 | cut -d'"' -f4)
                      if [ -n "$ORG_KEY" ]; then
                        echo "‚úÖ Auto-detected organization: $ORG_KEY"
                        echo "SONARCLOUD_ORG=$ORG_KEY" >> $GITHUB_ENV
                      else
                        echo "‚ùå Could not extract organization key from API response"
                        echo "Please set SONARCLOUD_ORG secret manually"
                        echo "You can find it at: https://sonarcloud.io/organizations/"
                        exit 1
                      fi
                    else
                      echo "‚ùå Could not connect to SonarCloud API or no organizations found"
                      echo "Trying alternative method..."

                      # Alternative: Try to get organization from project info
                      PROJECT_RESPONSE=$(curl -s -u "$SONARCLOUD_TOKEN:" "https://sonarcloud.io/api/projects/search?projects=Grosint_backend" || echo "")
                      if [ -n "$PROJECT_RESPONSE" ] && echo "$PROJECT_RESPONSE" | grep -q '"organization"'; then
                        ORG_KEY=$(echo "$PROJECT_RESPONSE" | grep -o '"organization":"[^"]*"' | head -1 | cut -d'"' -f4)
                        if [ -n "$ORG_KEY" ]; then
                          echo "‚úÖ Auto-detected organization from project: $ORG_KEY"
                          echo "SONARCLOUD_ORG=$ORG_KEY" >> $GITHUB_ENV
                        else
                          echo "‚ùå Could not extract organization from project info"
                          echo "Please set SONARCLOUD_ORG secret manually"
                          echo "You can find it at: https://sonarcloud.io/organizations/"
                          exit 1
                        fi
                      else
                        echo "‚ùå Could not connect to SonarCloud API or project not found"
                        echo "Please set SONARCLOUD_ORG secret manually"
                        echo "You can find it at: https://sonarcloud.io/organizations/"
                        exit 1
                      fi
                    fi
                  else
                    echo "‚úÖ SonarCloud organization is configured"
                    echo "SONARCLOUD_ORG=$SONARCLOUD_ORG" >> $GITHUB_ENV
                  fi

            - name: Test SonarCloud Connection
              if: env.SONARCLOUD_TOKEN != ''
              env:
                  SONARCLOUD_TOKEN: ${{ secrets.SONARCLOUD_TOKEN }}
              run: |
                  echo "Testing SonarCloud connection..."
                  curl -s -u "$SONARCLOUD_TOKEN:" "https://sonarcloud.io/api/authentication/validate" || echo "Connection test failed"

                  echo "Organization: $SONARCLOUD_ORG"
                  echo "Project Key: Grosint_backend"

            - name: Update SonarCloud Properties
              if: env.SONARCLOUD_TOKEN != ''
              env:
                  SONARCLOUD_TOKEN: ${{ env.SONARCLOUD_TOKEN }}
                  SONARCLOUD_ORG: ${{ env.SONARCLOUD_ORG }}
              run: |
                  echo "Updating sonar-project.properties with detected organization..."
                  # Update the organization in sonar-project.properties
                  sed -i "s/sonar.organization=.*/sonar.organization=$SONARCLOUD_ORG/" sonar-project.properties
                  echo "Updated sonar-project.properties:"
                  cat sonar-project.properties

            - name: Disable Automatic Analysis
              if: env.SONARCLOUD_TOKEN != ''
              env:
                  SONARCLOUD_TOKEN: ${{ secrets.SONARCLOUD_TOKEN }}
              run: |
                  echo "Disabling automatic analysis for CI compatibility..."

                  # Check current automatic analysis status
                  echo "Checking current automatic analysis status..."
                  STATUS_RESPONSE=$(curl -s -u "$SONARCLOUD_TOKEN:" "https://sonarcloud.io/api/automatic_analysis/status?project=Grosint_backend")
                  echo "Current status: $STATUS_RESPONSE"

                  # Disable automatic analysis via API
                  echo "Attempting to disable automatic analysis..."
                  DISABLE_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
                    -u "$SONARCLOUD_TOKEN:" \
                    "https://sonarcloud.io/api/automatic_analysis/disable" \
                    -d "project=Grosint_backend")

                  HTTP_CODE=$(echo "$DISABLE_RESPONSE" | tail -n1)
                  RESPONSE_BODY=$(echo "$DISABLE_RESPONSE" | head -n -1)

                  echo "HTTP Status: $HTTP_CODE"
                  echo "Response: $RESPONSE_BODY"

                  if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "204" ]; then
                    echo "‚úÖ Automatic analysis disabled successfully"
                  else
                    echo "‚ö†Ô∏è  Failed to disable automatic analysis via API (HTTP $HTTP_CODE)"
                    echo "You may need to disable it manually in SonarCloud project settings"
                  fi

            - name: SonarCloud Scan
              if: env.SONARCLOUD_TOKEN != ''
              uses: SonarSource/sonarqube-scan-action@master
              env:
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
                  SONAR_TOKEN: ${{ secrets.SONARCLOUD_TOKEN }}
                  SONARCLOUD_ORG: ${{ env.SONARCLOUD_ORG }}
              with:
                  args: >
                      -Dsonar.organization=${{ env.SONARCLOUD_ORG }}
                      -Dsonar.host.url=https://sonarcloud.io
              continue-on-error: true

            - name: SonarCloud Scan Fallback
              if: env.SONARCLOUD_TOKEN != '' && failure()
              env:
                  SONARCLOUD_TOKEN: ${{ env.SONARCLOUD_TOKEN }}
              run: |
                  echo "‚ùå SonarCloud scan failed due to automatic analysis conflict"
                  echo ""
                  echo "üîß TO FIX THIS ISSUE:"
                  echo "1. Go to your SonarCloud project: https://sonarcloud.io/project/overview?id=Grosint_backend"
                  echo "2. Click on 'Administration' ‚Üí 'Analysis Method'"
                  echo "3. Disable 'Automatic Analysis'"
                  echo "4. Save the changes"
                  echo "5. Re-run this pipeline"
                  echo ""
                  echo "This will allow CI analysis to work properly."
                  echo "The pipeline will continue without SonarCloud analysis for now."

            - name: Check SonarCloud Scan Results
              if: env.SONARCLOUD_TOKEN != ''
              env:
                  SONARCLOUD_TOKEN: ${{ env.SONARCLOUD_TOKEN }}
              run: |
                  if [ -f "target/sonar/report-task.txt" ]; then
                    echo "‚úÖ SonarCloud scan completed successfully"
                    echo "SONARCLOUD_SCAN_SUCCESS=true" >> $GITHUB_ENV
                  else
                    echo "‚ùå SonarCloud scan failed or was skipped"
                    echo "SONARCLOUD_SCAN_SUCCESS=false" >> $GITHUB_ENV
                  fi

            - name: SonarCloud Quality Gate
              if: env.SONARCLOUD_TOKEN != '' && env.SONARCLOUD_SCAN_SUCCESS == 'true'
              uses: SonarSource/sonarqube-quality-gate-action@master
              env:
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
                  SONAR_TOKEN: ${{ secrets.SONARCLOUD_TOKEN }}
                  SONARCLOUD_ORG: ${{ env.SONARCLOUD_ORG }}
              with:
                  scanMetadataReportFile: target/sonar/report-task.txt

            - name: SonarCloud Quality Gate Skipped
              if: env.SONARCLOUD_TOKEN != '' && env.SONARCLOUD_SCAN_SUCCESS == 'false'
              env:
                  SONARCLOUD_TOKEN: ${{ env.SONARCLOUD_TOKEN }}
              run: |
                  echo "‚è≠Ô∏è  Skipping SonarCloud Quality Gate - scan was not successful"
                  echo "This is expected when automatic analysis is enabled in SonarCloud"

            - name: Stop MongoDB container
              if: always()
              run: docker compose -f docker-compose.test.yml down -v

            - name: Upload coverage reports
              uses: actions/upload-artifact@v4
              with:
                  name: coverage-reports
                  path: |
                      coverage.xml
                      htmlcov/

    build:
        name: üèóÔ∏è Build Application
        runs-on: ubuntu-latest
        needs: [lint, test]

        steps:
            - name: Checkout code
              uses: actions/checkout@v4

            - name: Create deployment package
              run: |
                  mkdir -p dist

                  # Copy application files
                  cp -r app/ dist/
                  cp requirements.txt dist/
                  cp run.py dist/

                  # Copy monitoring stack files
                  cp -r monitoring/ dist/
                  cp docker-compose.logs.yml dist/

                  # Note: Nginx and systemd configurations are created by setup.sh
                  # No need to create them here as they already exist on the server

                  # Create deployment script
                  cat > dist/deploy.sh << 'EOF'
                  #!/bin/bash
                  set -e

                  echo "üöÄ Starting deployment..."

                  # Create Python virtual environment
                  python3.12 -m venv venv
                  source venv/bin/activate
                  pip install --upgrade pip
                  pip install -r requirements.txt

                  echo "‚úÖ Dependencies installed"
                  EOF
                  chmod +x dist/deploy.sh

                  # Create monitoring deployment script
                  cat > dist/deploy-monitoring.sh << 'EOF'
                  #!/bin/bash
                  set -e

                  echo "üìä Starting monitoring stack deployment..."

                  # Create monitoring directory
                  sudo mkdir -p /opt/grosint-monitoring
                  sudo chown $USER:$USER /opt/grosint-monitoring

                  # Copy monitoring files
                  cp -r monitoring/ /opt/grosint-monitoring/
                  cp docker-compose.logs.yml /opt/grosint-monitoring/

                  # Create systemd service for monitoring stack
                  sudo tee /etc/systemd/system/grosint-monitoring.service << MONEOF
                  [Unit]
                  Description=Grosint Monitoring Stack (Grafana, Loki, Prometheus)
                  Requires=docker.service
                  After=docker.service

                  [Service]
                  Type=forking
                  RemainAfterExit=yes
                  WorkingDirectory=/opt/grosint-monitoring
                  # Use shell to detect available compose command
                  ExecStart=/bin/bash -c 'if command -v docker >/dev/null 2>&1 && docker compose version >/dev/null 2>&1; then docker compose -f docker-compose.logs.yml up -d; else docker-compose -f docker-compose.logs.yml up -d; fi'
                  ExecStop=/bin/bash -c 'if command -v docker >/dev/null 2>&1 && docker compose version >/dev/null 2>&1; then docker compose -f docker-compose.logs.yml down; else docker-compose -f docker-compose.logs.yml down; fi'
                  TimeoutStartSec=0
                  # Pin an explicit, non-root user that owns /opt/grosint-monitoring
                  User=${USER}
                  Restart=on-failure
                  RestartSec=10

                  [Install]
                  WantedBy=multi-user.target
                  MONEOF

                  # Enable and start monitoring service
                  sudo systemctl daemon-reload
                  sudo systemctl enable grosint-monitoring
                  sudo systemctl start grosint-monitoring

                  echo "‚úÖ Monitoring stack deployed successfully!"
                  echo "Grafana: http://localhost:3000 (admin/[password from environment])"
                  echo "Prometheus: http://localhost:9090"
                  echo "Loki: http://localhost:3100"
                  echo "Note: Grafana password is set via GRAFANA_ADMIN_PASSWORD environment variable"
                  EOF
                  chmod +x dist/deploy-monitoring.sh

                  # Environment file will be created during deployment using GitHub Secrets

                  echo "Build package created successfully"
                  ls -la dist/

            - name: Upload build artifacts
              uses: actions/upload-artifact@v4
              with:
                  name: build-artifacts
                  path: dist/

    deploy:
        name: üöÄ Deploy to Production
        runs-on: ubuntu-latest
        needs: [lint, test, build]
        if: (github.event_name == 'push') || (github.event_name == 'pull_request' && github.event.pull_request.merged == true)
        environment:
            name: production

        steps:
            - name: Set deployment URL
              run: |
                  echo "Deployment URL: http://${{ secrets.DOMAIN_NAME }}:8000"
                  echo "DEPLOYMENT_URL=http://${{ secrets.DOMAIN_NAME }}:8000" >> $GITHUB_ENV

            - name: Download build artifacts
              uses: actions/download-artifact@v4
              with:
                  name: build-artifacts
                  path: dist/

            - name: Deploy to Azure VM
              uses: appleboy/ssh-action@v1.1.0
              with:
                  host: ${{ secrets.AZURE_VM_HOST }}
                  username: ${{ secrets.AZURE_VM_USERNAME }}
                  key: ${{ secrets.AZURE_VM_SSH_KEY }}
                  script_stop: true
                  script: |
                      echo "üõë Stopping current application..."
                      sudo systemctl stop grosint-backend || echo "Service not running"

                      # Create backup
                      if [ -d "/opt/grosint-backend" ]; then
                        sudo mv /opt/grosint-backend /opt/grosint-backend.backup.$(date +%Y%m%d_%H%M%S)
                      fi

                      # Create application directory
                      sudo mkdir -p /opt/grosint-backend
                      sudo chown $USER:$USER /opt/grosint-backend

            - name: Copy files to server
              uses: appleboy/scp-action@v0.1.4
              with:
                  host: ${{ secrets.AZURE_VM_HOST }}
                  username: ${{ secrets.AZURE_VM_USERNAME }}
                  key: ${{ secrets.AZURE_VM_SSH_KEY }}
                  source: "dist/*"
                  target: "/opt/grosint-backend"
                  strip_components: 1

            - name: Complete deployment
              uses: appleboy/ssh-action@v1.0.0
              with:
                  host: ${{ secrets.AZURE_VM_HOST }}
                  username: ${{ secrets.AZURE_VM_USERNAME }}
                  key: ${{ secrets.AZURE_VM_SSH_KEY }}
                  script: |
                      cd /opt/grosint-backend

                      # Debug: List all files to verify copying
                      echo "Files in deployment directory:"
                      ls -la

                      # Debug: Check user and permissions
                      echo "Current user: $(whoami)"
                      echo "User ID: $(id)"
                      echo "Virtual environment check:"
                      ls -la venv/bin/uvicorn || echo "uvicorn not found in venv/bin/"
                      echo "Python check:"
                      which python3.12 || echo "python3.12 not found"

                      # Set up application
                      chmod +x deploy.sh
                      ./deploy.sh

                      # Create .env file from GitHub Secrets
                      echo "Creating .env file from GitHub Secrets..."
                      cat > .env << EOF
                      # MongoDB Atlas Configuration
                      MONGODB_URL=${{ secrets.MONGODB_URL }}

                      # Application Configuration
                      DEBUG=false
                      LOG_LEVEL=info
                      SECRET_KEY=${{ secrets.SECRET_KEY }}

                      # Monitoring Configuration
                      GRAFANA_ADMIN_PASSWORD=${{ secrets.GRAFANA_ADMIN_PASSWORD }}

                      # Environment
                      ENVIRONMENT=production
                      EOF
                      echo "‚úÖ .env file created with production secrets"

                      # Create logs directory with proper permissions
                      sudo mkdir -p /opt/grosint-backend/logs
                      sudo chown $USER:$USER /opt/grosint-backend/logs
                      sudo chmod 755 /opt/grosint-backend/logs

                      # Systemd service and Nginx config are already created by setup.sh
                      # Just reload the services
                      sudo systemctl daemon-reload
                      sudo systemctl enable grosint-backend
                      sudo nginx -t
                      sudo systemctl reload nginx

                      # Set proper ownership for all files
                      # FastAPI runs as root, Nginx proxies to it (no direct file access needed)
                      sudo chown -R root:root /opt/grosint-backend
                      sudo chmod -R 755 /opt/grosint-backend

                      # Only give www-data access to logs (if Nginx needs to write logs)
                      sudo chown -R www-data:www-data /opt/grosint-backend/logs

                      # Start application
                      sudo systemctl start grosint-backend

                      # Wait and health check
                      echo "‚è≥ Waiting for application to start..."
                      sleep 15

                      # Health check
                      for i in {1..6}; do
                        if curl -f http://127.0.0.1:8000/api/health >/dev/null 2>&1; then
                          echo "‚úÖ Application health check passed!"
                          break
                        elif [ $i -eq 6 ]; then
                          echo "‚ùå Health check failed!"
                          echo "Trying to get health check response:"
                          curl -v http://127.0.0.1:8000/api/health || echo "Health check request failed"
                          sudo journalctl -u grosint-backend --no-pager -n 20
                          exit 1
                        else
                          echo "Attempt $i/6 failed, retrying..."
                          sleep 5
                        fi
                      done

                      echo "‚úÖ Deployment completed successfully!"
                      sudo systemctl status grosint-backend --no-pager

                      # Deploy monitoring stack
                      echo "üìä Deploying monitoring stack..."
                      chmod +x deploy-monitoring.sh
                      ./deploy-monitoring.sh

                      echo "‚úÖ Monitoring stack deployed!"
                      echo "Grafana: http://${{ secrets.DOMAIN_NAME }}:3000 (admin/[password from environment])"
                      echo "Prometheus: http://${{ secrets.DOMAIN_NAME }}:9090"
                      echo "Note: Grafana password is set via GRAFANA_ADMIN_PASSWORD environment variable"

    notify:
        name: üì¢ Slack Notification
        runs-on: ubuntu-latest
        needs: [lint, test, build, deploy]
        if: always()

        steps:
            - name: Set deployment URL
              run: |
                  echo "DEPLOYMENT_URL=http://${{ secrets.DOMAIN_NAME }}:8000" >> $GITHUB_ENV

            - name: Check Slack Configuration
              run: |
                  if [ -z "${{ secrets.SLACK_WEBHOOK_URL }}" ]; then
                    echo "‚ùå SLACK_WEBHOOK_URL secret is not configured"
                    echo "Please add SLACK_WEBHOOK_URL to your repository secrets"
                    exit 1
                  else
                    echo "‚úÖ Slack webhook URL is configured"
                  fi

            - name: Notify Success
              if: needs.deploy.result == 'success'
              uses: 8398a7/action-slack@v3
              env:
                  SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
              with:
                  status: success
                  channel: "#deployments"
                  custom_payload: |
                      {
                        "attachments": [
                          {
                            "color": "good",
                            "title": "üéâ Deployment Successful!",
                            "text": "All pipeline stages completed successfully on branch `${{ github.ref_name }}`",
                            "fields": [
                              {
                                "title": "Repository",
                                "value": "${{ github.repository }}",
                                "short": true
                              },
                              {
                                "title": "Branch",
                                "value": "`${{ github.ref_name }}`",
                                "short": true
                              },
                              {
                                "title": "Commit",
                                "value": "`${{ github.sha }}`",
                                "short": true
                              },
                              {
                                "title": "Author",
                                "value": "${{ github.actor }}",
                                "short": true
                              },
                              {
                                "title": "Pipeline Stages",
                                "value": "‚úÖ Lint\n‚úÖ Test\n‚úÖ Build\n‚úÖ Deploy",
                                "short": false
                              }
                            ],
                            "actions": [
                              {
                                "type": "button",
                                "text": "View App",
                                "url": "${{ env.DEPLOYMENT_URL }}"
                              },
                              {
                                "type": "button",
                                "text": "View Logs",
                                "url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                              },
                              {
                                "type": "button",
                                "text": "Grafana",
                                "url": "http://${{ secrets.DOMAIN_NAME }}:3000"
                              }
                            ]
                          }
                        ]
                      }

            - name: Debug Failure Payload
              if: needs.lint.result == 'failure' || needs.test.result == 'failure' || needs.build.result == 'failure' || needs.deploy.result == 'failure' || needs.lint.result == 'cancelled' || needs.test.result == 'cancelled' || needs.build.result == 'cancelled' || needs.deploy.result == 'cancelled'
              run: |
                  echo "Branch: ${{ github.ref_name }}"
                  echo "Lint result: ${{ needs.lint.result }}"
                  echo "Test result: ${{ needs.test.result }}"
                  echo "Build result: ${{ needs.build.result }}"
                  echo "Deploy result: ${{ needs.deploy.result }}"

            - name: Notify Failure
              if: needs.lint.result == 'failure' || needs.test.result == 'failure' || needs.build.result == 'failure' || needs.deploy.result == 'failure' || needs.lint.result == 'cancelled' || needs.test.result == 'cancelled' || needs.build.result == 'cancelled' || needs.deploy.result == 'cancelled'
              uses: 8398a7/action-slack@v3
              env:
                  SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
              with:
                  status: failure
                  channel: "#deployments"
                  custom_payload: |
                      {
                        "attachments": [
                          {
                            "color": "danger",
                            "title": "‚ùå Pipeline Failed!",
                            "text": "Pipeline failed on branch `${{ github.ref_name }}` - check details below",
                            "fields": [
                              {
                                "title": "Repository",
                                "value": "${{ github.repository }}",
                                "short": true
                              },
                              {
                                "title": "Branch",
                                "value": "`${{ github.ref_name }}`",
                                "short": true
                              },
                              {
                                "title": "Commit",
                                "value": "`${{ github.sha }}`",
                                "short": true
                              },
                              {
                                "title": "Author",
                                "value": "${{ github.actor }}",
                                "short": true
                              },
                              {
                                "title": "Pipeline Stages Status",
                                "value": "${{ needs.lint.result == 'success' && '‚úÖ Lint' || needs.lint.result == 'failure' && '‚ùå Lint' || needs.lint.result == 'cancelled' && '‚èπÔ∏è Lint' || '‚è≥ Lint' }}\n${{ needs.test.result == 'success' && '‚úÖ Test' || needs.test.result == 'failure' && '‚ùå Test' || needs.test.result == 'cancelled' && '‚èπÔ∏è Test' || '‚è≥ Test' }}\n${{ needs.build.result == 'success' && '‚úÖ Build' || needs.build.result == 'failure' && '‚ùå Build' || needs.build.result == 'cancelled' && '‚èπÔ∏è Build' || '‚è≥ Build' }}\n${{ needs.deploy.result == 'success' && '‚úÖ Deploy' || needs.deploy.result == 'failure' && '‚ùå Deploy' || needs.deploy.result == 'cancelled' && '‚èπÔ∏è Deploy' || '‚è≥ Deploy' }}",
                                "short": false
                              },
                              {
                                "title": "Failed Stage",
                                "value": "${{ needs.lint.result == 'failure' && 'üîç Lint Stage' || needs.test.result == 'failure' && 'üß™ Test Stage' || needs.build.result == 'failure' && 'üèóÔ∏è Build Stage' || needs.deploy.result == 'failure' && 'üöÄ Deploy Stage' || 'Unknown' }}",
                                "short": true
                              }
                            ],
                            "actions": [
                              {
                                "type": "button",
                                "text": "View Logs",
                                "url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                              },
                              {
                                "type": "button",
                                "text": "Retry Pipeline",
                                "url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}/rerun"
                              }
                            ]
                          }
                        ]
                      }

            - name: Notify Skipped
              if: needs.deploy.result == 'skipped' && (needs.lint.result == 'success' && needs.test.result == 'success' && needs.build.result == 'success')
              uses: 8398a7/action-slack@v3
              env:
                  SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
              with:
                  status: success
                  channel: "#deployments"
                  custom_payload: |
                      {
                        "attachments": [
                          {
                            "color": "warning",
                            "title": "‚ö†Ô∏è Pipeline Passed (No Deployment)",
                            "text": "All pipeline stages passed on branch `${{ github.ref_name }}` but deployment was skipped",
                            "fields": [
                              {
                                "title": "Repository",
                                "value": "${{ github.repository }}",
                                "short": true
                              },
                              {
                                "title": "Branch",
                                "value": "`${{ github.ref_name }}`",
                                "short": true
                              },
                              {
                                "title": "Commit",
                                "value": "`${{ github.sha }}`",
                                "short": true
                              },
                              {
                                "title": "Author",
                                "value": "${{ github.actor }}",
                                "short": true
                              },
                              {
                                "title": "Pipeline Stages Status",
                                "value": "‚úÖ Lint\n‚úÖ Test\n‚úÖ Build\n‚è≠Ô∏è Deploy (skipped)",
                                "short": false
                              },
                              {
                                "title": "Reason",
                                "value": "Deployment only runs on main/production branches",
                                "short": false
                              }
                            ],
                            "actions": [
                              {
                                "type": "button",
                                "text": "View Logs",
                                "url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                              },
                              {
                                "type": "button",
                                "text": "Merge to Deploy",
                                "url": "https://github.com/${{ github.repository }}/compare/main...${{ github.ref_name }}"
                              }
                            ]
                          }
                        ]
                      }

            - name: Debug Slack Configuration
              if: always()
              run: |
                  echo "Slack webhook configured: ${{ secrets.SLACK_WEBHOOK_URL != '' }}"
                  echo "Deploy result: ${{ needs.deploy.result }}"
                  echo "Lint result: ${{ needs.lint.result }}"
                  echo "Test result: ${{ needs.test.result }}"
                  echo "Build result: ${{ needs.build.result }}"
                  echo "Event name: ${{ github.event_name }}"
                  echo "Ref: ${{ github.ref }}"
                  echo "Ref name: ${{ github.ref_name }}"
